---
title: "2fa Authentication PHP"
date: 2022-08-08T21:34:25-03:00
tables: [coding, technology]
---
1. Introduction
2. What is the OTP?
3. URI Format
4. Enconding with Base32
5. Generating a QRCode

# 1.Introduction

For the last month, I have been working on a library for PHP that will implement the OTP(One Time Password) in an easy way. In the following topics, I will try to explain each technology and protocol that were used to build this software. If you don't want to pass for this technical stuff, you can just go to the explanation of the [library](https://github.com/JohhnMag0/2fa-php/blob/main/README.md).

# 2.What is the OTP?
To simple put a OTP is a One Time Password, it's basically a password that has the validation of one use only and is very widespread in two-factor authentication. There are a lot of ways that you can implement an OTP in hardware or software, with different types of algorithms involved in the generation of this password. In this article I will explain a little about the HOTP(HMAC-based OTP) and the TOTP(Time-based OTP).

- **HOTP:**
Before I try to explain what the HOTP is, it's important to get a glance at what a HMAC is. It stands for hash-based message authentication code, which is basically a nice way of saying that the message will be encrypted using a secret key. In simple terms, what HMAC will do is to get a message and a secret. He will then add those two together and, using an algorithm like SHA-1, he will scrumble things up, generating a hash.
Now that you get what is a HMAC we can pass to the [RFC 4226](https://datatracker.ietf.org/doc/html/rfc4226) that defines how a HOTP should look like and how to implement his algorithm.
This standard defines HOTP as a count-based or sequential-based method for generating one-time passwords, and each time a password is used, its count is incremented, usually by 1, which allows the generation of a completely new password. The number of digits, how the count will be incremented, and even the hash algorithm are things that can be changed. Because of this simplicity, HOTP can be implemented on a lot of devices(they basically just need to know how to count).
To use this OTP, a password is necessary that can be randomly generated by the system or created by the user, and the HMAC together with the algorithm will start to generate these codes see algorithm[^7]. From the point of view of the user, he will use that one-time password, and each time that he is successfully authenticated, he will need to refresh his password, increasing the value of his count.
Despite the simplicity of this protocol, there are some basic things that you can(and probably should) do to improve the security and reliability of your system. Two in particular are the most important ones. The first being a method against brute-force attacks, as the default generation of the password is usually 6 digits, it's quite simple to see all the possible combinations and pass this in a brute-force attack, so it's very important to be able to block the user after a certain number of attempts. And the second one is about the count value, if your user is using some app to generate this OTP for him(like google authenticator) your system does not know in which count your user is, and as we see, it becomes the user's responsibility to refresh their password that can desync the server from the user, so when you are implementing this protocol, it's very important to use a way to verify a window of values. To put it in a simple way, if  you have on your server a count of 0, you need to be able to look a few values further and then adjust your server count to sync with your user again.

- **TOTP:**
Defined by the [RFC 6238](https://datatracker.ietf.org/doc/html/rfc6238), TOTP is like a derivation of the HOTP that uses time instead of a counter for creating the password. All in all this protocol is basically the same as his precessor, the variables as the number of digits and the algorithms stays the same.
The big difference that is introduce in this version of the protocol is the use of the [UNIX timestamp](https://en.wikipedia.org/wiki/Unix_time). UNIX was one of the first operational systems invented, and is basically the dad of all the other systems that we have today, and one of the things that UNIX introduced was his way of counting time, he marks as his first day and age the 1st of January of 1970 00:00:00. This time standard is widespread in almost all systems today and because of this default we use this time to get the exactly number that we will use to generate or digits.
As we are not working with counts anymore we need to define a period of time(usually 30 seconds) on wich between this period of seconds the password is valid to be used.
One of the best things that version of the protocol introduces is the fact that the password will be regenerate within each period of time, so the user has no need to refresh the password every time he uses, and is also alot more safer because the password will be regenareted after each period of its life period. But(there is always a "butt") as this introduces more safety on the system it also introduces more problems, because now you can get clocks out of sync with is a huge problem, to solve that you can implement some control measures in my code for example I open a socket that verifys the time with a NTP(Network Time Protocol) Server but this also has it's problems(latency, server down ...), so other thing that you can do to minimize this problem is to create a window of time much like as said in HOTP count, where if you have a period of 30 seconds for example you can verify one minute before and one minute after, so if both sides are out of sync they can still comunicate.

- **Algorithm:**
Now that you understand the differences between HOTP and TOTP and how each one of them is used. We can go a little deep(just a little) into how the algorithm that generates these digits works. The first thing that needs to happen is to generate the hash to do that, we will need to know the count/time value, the secret and the algorithm for the hash. The secret and the hash are the easiest ones to get, the secret can be randomly generated or entered by the user, and for the hash, we just need to select one of the algorithms that are accepted by the hmac[https://www.php.net/manual/pt_BR/function.hash-hmac-algos.php](my code support only SHA1, SHA256 and SHA512), things get a little complicated when we get on the count/time because will need to transform the number in a binary string. Before I get into how I do that transformation, it's important that you understand 4 operators(valid in php) and how they work:

« » - Bitwise shift, this operator is used shift the position of the bits of a value. For example if we have the value 1 and we shift his bit four times to the left we will get the value 16. In the case of the values that are on the limit of the byte will double it's value(if for the left) or be null(if for the right)
| -Bitwise OR, will unify the number of bits on each side. So if we have the value "101 | 10" we will get in return the value "111", because it means one bit or another.
& - Bitwise AND, this will also unify the bits of each side, but just the ones that matches in each side. So if we have the value "010 & 11" will get in return the value "10".

Now we can get a look on the code that I use on my program, first the HOTP:
```php
<?php
for ($i = 7; $i >= 0; $i--){
	$byte_count[$i] = chr($count & 0xff);
	$count = $count >> 8;
}
```
As you see, we have a loop that will go on each byte of the number that is being passed on the count, then I get the bits of the variable "$count" with the mask 0xff(that means a full byte long), passing that value to the function chr that transforms the number into a character based on the ASCII table. And last but not least, I shift eight bits to the right, so that I can get the next byte of that number. If at the end of this process, the string that I got is less than 8 bytes, I add 0, until it gets 8 bytes in length.

Let's go to the TOTP part:
```php
<?php
$binary_timestamp = pack('N*', 0) . pack('N*', floor($unix_time/$period));
```
As you can see, we have a more simple line of code. Basically, here we are packing(in php and perl transforms the data into a binary string) the time value, as you see, this is done in two parts the first one is with the value 0 and the other one with the length of time itself, this is done because with the time itself alone, we don't get the full 8 bit value, so we need to add the 0 for padding.

With the count/time in hand, we can finally create the hash that we need. We then pass the hash to the algorithm that will generate the password we need. He works in a simple manner(if you are an insane mathematician), so first of all we get the bytes of the hash and put them in pairs that will put them in a hexdecimal code that we will transform into decimal. With that done, we now get to the algorithm:
```php
<?php
$offset = $decimal[count($decimal) - 1] & 0xf;

$code = ($decimal[$offset] & 0x7f) << 24
| ($decimal[$offset+1] & 0xff) << 16
| ($decimal[$offset+2] & 0xff) << 8
| ($decimal[$offset+3] & 0xff);

$token = $code % pow(10, $length);
 ```
As we see, we have an offset that will be our starting point, and we get that offset by the last four number of bits this will define the other 4 bytes that we are going to use, as you can see in the code part. And at last but not least important we get the value of the union of all these 4 bytes, and then we divide this value by 10 to get the number of digits you want to generate (usually 6). The module of this result will get your password.

See how it's simple. I bet that with a few bottles of coffee, some packs of cigarettes, and sleepless nights, you would get to this algorithm too in no time.

# 3.URI Default Format
If you have already used a 2factor authentication, you have probably read a QRCode Google Authenticator([AEGIS](https://getaegis.app/) is better) and he started to generate the OTP, for the system be able to generate the QRCode he needs a base text value that will contain all the variables and useful information for the generation of the code.  That URI is well defined by [Google](https://github.com/google/google-authenticator/wiki/Key-Uri-Format)(did I already mention that [AEGIS](https://getaegis.app/) is better?):

otpauth://{totp|hotp}/{issuer}:{user}?secret={base32}&issuer={issuer}&algorithm={algo}&digits={number}&period|count={time|count}

totp|hotp - Here we define the protocol that is being used

issuer - In the issuer you can define the name of the programa or company

user - Is the name of the user

base32 - Here is where we pass or secret(because base32 is super secure). We do that because the secret can have some non legible characters that need to be enconded to be passed to other systems.

algo - The algorithm that is being used to generate the hash

number - Number of digits on the system

period|count - In the case of the protocol chosen being the totp you use the period, if is the hotp then use the count

time|count - Define the number of seconds to generate the password(totp). Define the initial count(hotp)

Most of these parameters being passed by this URI are optional, you don't need to pass all this values just the issuer user and the secret are really necessary. But remember if you don't pass the valuables the default option is gonna be used(count=0, period=30 and algorithm=SHA1):

otpauth://{totp|hotp}/{issuer}:{user}?secret={base32}

# 4.Enconding with Base32

For my library to be able to generate the URI format it needs to be able to encode a string in base32, and for that unfortunally php(why php? why you do that to me?) doesn't have a pre-built library, so I need to improvise and create another library that does this encode and decode on base32. 
It's good to mention that for base64, base32 and base16 there is a [RFC 4648](https://www.rfc-editor.org/rfc/rfc4648.html)(what we would do without you IEEE) that describes how this should be implemented. So, long story short, by this standard we have an alphabet of 31 characters(including letters and digits), where each has a value that maps a number to a character(ex. 19 - T). 
To put it in a simple way, what the b32 encode does is he gets the first 5 bits of the string, and with the value of these 5 bytes he maps to a character in his own alphabet, and then he does this process until there are no bits left, there are some cases where some bits are missing in this case, it is necessary to padd the string with the '=', but we are not going to do that on this library(some rules are meant to be broken). And to decode, the reverse process is used, where the library gets the first 8 bits and transforms them into a character, before moving to the next 8.

link for the library: [base32 library](https://github.com/JohhnMag0/base-php).

# 5.Generating a QRCode

In the QRCode area, I will not extend myself very much. Basically, I used a [library](https://github.com/kazuhikoarase/qrcode-generator) to get that URI in text and transform it into the QRCode image that will be scanned. One of the cool things about this library is that it can define the size of the QRCode, the level of correction, the mode(numeric, alphanumeric, byte and kanji) and we can even define if we will save the QRCode as an image or HTML.
I know that I said that I would not extend myself on this subject ~~I lied~~, but I really think that it is good to know what the QR Code is and how this technology works. The QR Code, stands for Quick Response Code, and was invented as an evolution of the barcode as a way to insert more data into that code, one of the ways they inveted to add more data was to use the code in a vertical and horizontal way(instead of just horizontal as the barcode does) and then, on top of that, they added those little black squares on some edges of the code so it becomes faster to read for the system to recognize the code. In top of that this code uses the [Reed-Solomon algorithm](https://en.wikipedia.org/wiki/Reed%E2%80%93Solomon_error_correction) to implement a error correction, so when the QR Code is dirty or damaged it can still be readed(what is very nice).
As I have said I will not extend myself on how the QR Code is generated or how it works, but you should definetely give a look on the official site to get a ideia of how powerfull QR Code can be.

https://www.qrcode.com/en/

# END

I think with that article you already get a glimpse of what the OTP, and what the technologies that are used to create this password are. If you want to use this library in one of your projects or if you wanna use the code to tranform in something better you are totally free to do that, you can get the source in my [github](https://github.com/JohhnMag0/2fa-php) or [gitlab](https://gitlab.com/fisrt/2fa-php), in the repository there is a README file that explains how to use the library to generate the OTP, the URI and the QR Code. 

Tha-tha-that's All Folks.
